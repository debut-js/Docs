<style>
tr td:not(:nth-child(1)) {
   text-align: center;
}
</style>

# Debut

Debut - это экосистема для разработки и запуска торговых стратегий. Аналог известного `ZenBot`, но с гораздо более гибкими возможностями для конструирования стратегий. Все что вам нужно сделать, это придумать и описать точки входа в рынок и подключить нужные [плагины](https://github.com/debut-js/Plugins) для работы. Все остальное - дело техники: **генетические алгоритмы** - помогут подобрать самые эффективные параметры для стратегии (период, стопы, и другие), **модуль подбора тикеров** - поможет найти подходящий для стратегии актив (токен или акцию), на котором она будет работать лучше всего.

В основе Debut лежит архитектура ядра и надстраиваемых плагинов, позволяющих гибко кастомизировать любые решения. Оснвной целью всей экосистемы Debut, является упрощение процесса создания и запуска рабочих торговых роботов на различные биржи. На данный момент поддерживаются: **Тинькофф Инвестици** и **Binance**.

В проекте есть две стартовые торговые стратегии "Для примера" как нужно работать с системой.

Пример работы стратегии [SpikesG](/src/strategies/spikes-grid/ReadMe.md) за 200 дней. Оптимизация проводилась за 180 дней и 20 дней свободной работы на необученных данных.
Использовался стартовый депозит в размере *500$*

<p align="center"><img src="https://github.com/debut-js/Strategies/raw/master/src/strategies/spikes-grid/img/BATUSDT.png" width="800"></p>

Статистика стратегии собиралась на основе плагина [статистики](https://github.com/debut-js/Plugins/tree/master/packages/stats), по ссылке можно подробнее узнать о значении некоторых статистических данных.

Визуализация выполнена с помощью плагина [Report](https://github.com/debut-js/Plugins/tree/master/packages/report).

## Community edition
Мы верим в силу сообщества! Именно поэтому решили опубликовать проект. Комьюнити версия бесплатная, но имеет некоторые ограничения в коммерческом использовании (доход от торговли стартегий не является коммерцией), а также технические отличия в тестировании стратегий. Присоединяйтесь к комьюнити, вступайте в **[чат разработчиков](https://t.me/joinchat/Acu2sbLIy_c0OWIy)**

## Enterprise edition
Энтерпрайз версия - это готовый набор инструментария для "больших дядек", для тех, кто занимается услугами торговли или создания стратегий профессионально. Здесь есть всё! И это всё уже готово работать на вас и на повышение скорости вашей разработки.


## Прямой эфир сделок

<p style="max-width:500px">
<iframe id="preview" style="height:500px;width:500px;" src="https://xn--r1a.website/s/debutjs"></iframe>
</p>

<table>
<thead>
<tr>
<th>Функционал</th>
<th>Community</th>
<th>Enterprise</th>
</tr>
</thead>
<tbody><tr>
<td>Тестер стратегий</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>Эмуляция OHLC тиков в тестере</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>Моудль поиска (finder) подходящих под стратегию активов</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>Набор плагинов из <a href="https://github.com/debut-js/Plugins" target="_blank" rel="noopener">коллекции</a></td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>Базовый набор готовых торговых стратегий</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>Данные свеч м1 для эмуляция тиков</td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td>Синтетическая эмуляция тиков в тестере (размер тика не более 0.75%)</td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td>Система управления рисками</td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td>Отчеты о работе в <a href="https://t.me/debutjs" target="_blank" rel="noopener">мессенджер</a></td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td>Готовые решения для запуска на VPS/VDS и Cloud серверах</td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td>Техническая поддержка</td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td>Не ограниченое кол-во подключений TCP на Тинькофф API (<a href="https://tinkoffcreditsystems.github.io/invest-openapi/marketdata/" target="_blank" rel="noopener">о лимитах</a>)</td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td>Система быстрых подписок на сигналы по токену, для продаж сигналов</td>
<td>❌</td>
<td>✅</td>
</tr>
</tbody></table>

Мы ведем прямой эфир сделок на основе Enterprise решения в нашем [телеграмм канале](https://t.me/debutjs)

**Узнайте цену, отправив запрос на [sales@debutjs.io](mailto:sales@debutjs.io)**

**Дисклеймер**

- Debut не гарантирует 100% вероятности получения прибыли. Используйте его на свой страх и риск, полагаясь на собственный проффесионализм.
- Криптовалюта это глобальный эксперимент, поэтому Debut - тоже. То есть оба могут выйти из строя в любой момент.

<hr/>

## Модули командной строки

<h3> Генетический оптимизатор </h3>

В его основе лежит модуль генетики [async-genetic](https://www.npmjs.com/package/async-genetic), который позволяет находить оптимальные решения для различных задач. Генетический оптимизатор способен гораздо более эффективно подбирать наилучшие параметры, в сравнении сравнению с простым случайным перебором значений (Brutforce).

### Одиночный **genetic**

Одиночный вызов генетического оптимизатора, используется для настройки стратегии под оптимизацию во время разработки. Например, для проверки на корректность [схемы оптимизации](#geneticschema), прочих этапов создания робота и его работу по время оптимизации в целом.

Но может применятся и как разовая оптимизация на заранее известном инструменте, для быстрого получения результата.

Запускается при помощи вызова команды:

```bash
npm run genetic -- [...args]
```
<h4> Параметры запуска </h4>

<h5>

*`--bot=...`*

</h5>

__Описание:__ Имя торгового робота из файла `schema.json`

__Пример:__ `--bot=SpikesG`

<h5>

*`--ticker=...`*

</h5>

__Описание:__ Инструмент для работы, обязательно должен быть в файле `cfgs.ts`, в директории стратегии

__Пример:__ `--ticker=AAPL`, `--ticker=BTCUSDT`

<h5>

*`--amount=...`*

</h5>

__Описание:__ Начальная сумма для торговли (от нее считается [equityLevel](#debutoptions)) `schema.json`

__Пример:__ `--amount=500`

<h5>

*`--days=...`*

</h5>

__Описание:__ Число дней для загрузки истории, если она есть. Загружаемая история сохраняется в директорию `./history` для переиспользования

__Пример:__ `--days=200`

<h5>

*`--gap=...`*

</h5>

__Описание:__ Сколько дней отступить от сегодня перед началом запроса истории

__Рекомендации:__ Используется для создания интервала котором не прходило обучение. Если мы передали настройку `--days=150` и настройку `--gap=50` то образуется 50 дней истории для запуска в тестере и тестировании на необученных данных, достаточно будет передать в тестере `--days=200` тогда мы захватим весь период обучения, плюс новые 50 дней отступа

__Пример:__ `--gap=20`

<h5>

*`--pop=...`*

</h5>

__Описание:__ Размер популяции в генетическом алгоритме (популяция это кол-во создаваемых стратегий)

__Рекомендации:__ Размер популяции рекомендуется устанавливать в диапазонах от `100` до `1500`, но больше не значит лучше! Значение весьма индивидуально, большие популяции увеличивают вероятность мутаций и прочих случайных явлений. Делайте фокус на количество поколений

__Пример:__ `--pop=500`

<h5>

*`--gen=...`*

</h5>

__Описание:__ Количество поколений в оптимизации

__Рекомендации:__ Сила генетики в поколениях, рекомендуемые значения от `10` до `100`, больше значит лучше. Однако следите за переученностью, проверяя стратегию на новых исторических данных. Велика вероятность адаптации к конкретным условиям изменения цены, при очень большом количестве поколений.

__Пример:__ `--gen=20`

<h5>

*`--ohlc`*

</h5>

__Описание:__ Механизм предназначен для более близкого точного отслеживания изменения цен. Разбивает каждую свечу в истории на 4 тика.

__Пример:__ `--ohlc`

<h5>

*`--best=...`*

</h5>

__Описание:__ Сколько лучших результатов выдать в консоль по окончанию оптимизации, по умолчанию `30`

__Пример:__ `--best=20`


<h5>

*`--log`*

</h5>

__Описание:__ Выводить ли промежуточные данные о поколении в консоль

__Рекомендации:__ Используйте при разработке стратегий и проверки их в генетике, или вообще всегда.

__Пример:__ `--log`


Пример запуска:

```bash
npm run compile && npm run genetic -- --bot=SpikesG --ticker=CRVUSDT --days=180 --gap=20 --gen=20 --pop=100 --log --amount=500
```


### Поиск тикеров **finder**
Это модуль подбора тикера под стратегию, перебирает все доступные тикеры для акций из файла `./stocks.json`, для криптовалюты из файла `./crypt.json`
Для каждого тикера выполняется генетический подбор параметров в процессе. На выходе вы получаете готовые результаты для каждого тикера. Удобно оставить на ночь.

Результаты будут создаваться в виде отчетов в JSON формате конфигурация + ее статистика. Отчеты складываются в папку `./public/reports/...`
При работе модифицируются файлы `stocks.json` или `crypt.json`, не забудьте откатить изменения после завершения подбора тикеров.

*Запускается при помощи вызова команды:*
```bash
npm run finder -- [...args]
```

<h4> Параметры запуска </h4>

Основные параметры те же, что и у [genetic](#Одиночный-genetic), с одним отличием

<h5>

*`--crypt`*

</h5>

__Описание:__ Использовать ли файл `crypt.json` для работы (по умолчанию используется `stocks.json` со списком акций)

__Пример:__ `--crypt`

__Рекомендации:__ Процесс заканчивает работу после обработки одного тикера, для цикличных перезапусков используйте `pm2`, ниже приведены примеры запусков процесса поиска тикеров.

*Mac/Linux*
```bash
npm run compile && pm2 start finder -n instance -- --ticker=NDAQ --bot=SpikesG --amount=1000 --days=1000 --log --useTicks --pop=100 --gen=50
```

*Windows:*
```bash
npm run compile && pm2 start node_modules/@debut/enterprise-core/lib/cli/finder.js -f -- --ticker=ZILUSDT --bot=SpikesG --amount=500 --gen=50 --pop=300 --days=180 --gap=20 --log --useTicks --crypt
```
### Тестер страгий **tester**
Это модуль тестирования стратегий. Он используется во время разработки, для проверки открытия и закрытия позиций в нужных местах и работы стрегии в целом. Также для создания визуализаций готовых алго стратегий.

*Запускается при помощи вызова команды:*
```bash
npm run testing -- [...args]
```
<h4>Параметры запуска</h4>

<h5>

*`--bot=...`*

</h5>

__Описание:__ Имя торгового робота из файла `schema.json`

__Пример:__ `--bot=SpikesG`

<h5>

*`--ticker=...`*

</h5>

__Описание:__ Инструмент для работы, обязательно должен быть в файле `cfgs.ts`, в директории стратегии

__Пример:__ `--ticker=AAPL`, `--ticker=BTCUSDT`

<h5>

*`--days=...`*

</h5>

__Описание:__ Число дней для загрузки истории, если она есть. Загружаемая история сохраняется в директорию `./history` для переиспользования

__Пример:__ `--days=200`

<h5>

*`--gap=...`*

</h5>

__Описание:__ Сколько дней отступить от сегодня перед началом запроса истории

__Рекомендации:__ Используется для создания интервала котором не прходило обучение. Если мы передали настройку `--days=150` и настройку `--gap=50` то образуется 50 дней истории для запуска в тестере и тестировании на необученных данных, достаточно будет передать в тестере `--days=200` тогда мы захватим весь период обучения, плюс новые 50 дней отступа

__Пример:__ `--gap=20`

<h5>

*`--ohlc`*

</h5>

__Описание:__ Механизм предназначен для более близкого точного отслеживания изменения цен. Разбивает каждую свечу в истории на 4 тика.

__Пример:__ `--ohlc`

<h5>

*Пример запуска:*
```bash
npm run compile && npm run testing -- --ticker=TSLA --bot=SpikesG --days=200 --olhc
```

## Разработка плагинов
Архитектура плагинов посторения на использовании вызовов определенных фукнций (далее хуки), с целью перехвата событий происходящих в системе.
Некоторые виды хуков позволяют останавливать события, некоторые имеют пассивный статус без влияния на происходящее. Архитектура плагина должны быть выстраена таким образом, чтобы не влиять на производительность в генетическом оптимизаторе.

Весь плагин это функция, возвращающая объект содержаший поле `name` - это имя плагина, оно должно быть уникально в рамках используемых плагинов, `api` - это внешние методы плагина, для вызовов внутри стратегии, ну и остальные поля объекта это набор хуков.

```javascript
export function pluginConstructor(): PluginInterface {
    const variable = 23;
    return {
        name: 'MyPluginName',
        api: {
            getVariable() {
                return variable;
            },
        // ... hooks
    };
}

```

### Хуки
Ниже перечислен весь набор доступных хуков плагинов.

*`[onInit]: () => void;`*

Инициализация плагина, здесь можно что-нибудь создать или подключить другой плагин по его имени используя вызов `this.findPlugin(name)`

*`[async onStart]: () => Promise<void>;`*

Стратегия подписалась на биржевые данные и получает их в реальном времени.

*`[async onDispose]: () => Promise<void>;`*

Стратегия отписалась от биржевых данных и завершила работу. Хорошая возможность подчистить память плагина.

*`[async onBeforeOpen]: (order: OrderOptions) => Promise<boolean | void>;`*

Стратегия пытается открыть сделку, опции сделки доступны в качестве аргумента. Хук поддерживает режим блокировки действия если возвращает `true`, в таком случае сделка не будет создана.

*`[async onOpen]: (order: ExecutedOrder) => Promise<void>;`*

Сделка создана, можно получить ее как аргумент и собрать нужные данные о ней. На момент вызова хука операции на рынке уже исполнены.

*`[async onBeforeClose]: (order: OrderOptions, closing: ExecutedOrder) => Promise<boolean | void>;`*

Стратегия пытается закрыть сделку `closing`, опции сделки закрытия доступны в качестве аргумента `order`. Хук поддерживает режим блокировки действия если возвращает `true`, в таком случае сделка не будет закрыта, но попытки ее закрыть будут продолжаться по логике стратегии.

*`[async onClose]: (order: ExecutedOrder, closing: ExecutedOrder) => Promise<void>;`*

Сделка закрыта, в качестве аргументов передаются сделка которую закрываем `closing` и сделка которой закрываем `order`. На момент вызова хука операции на рынке уже исполнены.

*`[async onCandle]: (candle: Candle) => Promise<void>;`*

Текущая свеча закрылась. Данные свечи доступны в аргументе `candle`

*`[async onAfterCandle]: (candle: Candle) => Promise<void>;`*

Текущая свеча закрылась и отработали хуки `onCandle` можно что-нибудь сделать.

*`[async onTick]: (tick: Candle) => Promise<void>;`*

Пришел новый тик по текущей свече. Все тики идут в этот обработчик. Также поддерживает блокировку события, если вернет `true`, тик не будет передан стратегии. Используется например для ограничений торговых сессий. Чтобы отключать стратегию от рынка виртуально в зависимости от времени или дня недели или фазы луны.


### Контекст выполнения

Все хуки выполняются в контексте плагина, обращения к `this.` внутри любого хука будут привязаны к объекту ниже. Все аргументы передаваемые через хуки мутабильны, так что будьте осторожны.

Сама стратегия доступна как `this.debut` и вы имеете доступ ко всем публичным методам и атрибутам ядра.

`this.debut.orders` - список активных сделок, `this.debut.closeOrder` - закроет сделку, `this.debut.opts` - поможет получить доступ к настройкам стратегии.


Интерфейс контекста
```javascript
interface PluginCtx {
    findPlugin<T extends PluginInterface>(name: string): T;
    debut: DebutCore;
}
```

### Примеры
#### Простой плагин
Рассмотрим пример одного из самый простых плагинов, который прибавляет полученую прибыль к существующему балансу стартегии.

```javascript
import { PluginInterface } from '@debut/types';
import { orders } from '@debut/plugin-utils';

export function reinvestPlugin(): PluginInterface {
    // this = undefined здесь
    // но можно использовать отложенное присвоение так:
    let ctx: PluginCtx;

    return {
        name: 'reinvest',

        onInit() {
            ctx = this;
        },

        async onClose(order, closing) {
            // this = PluginCtx  здесь
            if (!order.openPrice) {
                return;
            }

            const profit = orders.getCurrencyProfit(closing, order.price) - order.commission.value;

            // this -> PluginCtx
            this.debut.opts.amount += profit;
        },
    };
}

```

#### Плагин шаг за шагом


**Создадим общий тип плагина и экспортируем его**
```javascript
export interface DynamicTakesPlugin extends PluginInterface {
    name: 'dynamicTakes';
    api: Methods;
}
```

**Экспортируем тип с параметрами плагина, для его подключения к debut.opts**
```javascript
export type DynamicTakesPluginOptions = {
    trailing?: boolean;
    ignoreTicks?: boolean;
    maxRetryOrders?: number;
};
```

**Отдельно объявим интерфейс публичных методов плагина (он приватный, экспорта нет)**
```javascript
interface Methods {
    setForOrder(orderId: string, takePrice: number, stopPrice: number): void;
    getTakes(orderId: string): OrderTakes;
}
```

**Экспортируем интерфейс API плагина для вызова через `this.plugins.dynamicTakes.setForOrder()` из стратегии**
```javascript
export interface DynamicTakesPluginAPI {
    dynamicTakes: Methods;
}
```

*NB!: Все публичные методы плагинов будут доступны из стратегии с помощью обращения через `this.plugins[имя плагина]`*


Полный листинг плагина доступен [здесь](https://github.com/debut-js/Plugins/blob/master/packages/dynamic-takes/index.ts)


## Типы данных **@debut/types**

Типы данных располагаются в отдельном пакете, для установки выполнить команду

```bash
npm i --save-dev @debut/types
```
### `Candle`
Форма представление рыночных данных. Используется как для тиков, так и для сформировавшихся свеч. Унифицированный стандарт, не зависит от выбора торговой площадки.

```javascript
interface Candle {
    o: number;
    c: number;
    h: number;
    l: number;
    v: number;
    time: number;
}
```
### `TimeFrame`
Унифицированный формат таймфрейма для работы стратегии, в списке только поддерживаемые форматы.

```javascript
type TimeFrame = '1min' | '3min' | '5min' | '15min' | '30min' | '1h' | '2h' | '4h' | 'day' | 'week' | 'month';
```
### `WorkingEnv`
Переменные окружения среды выполнения. Необходимо разделять все этапы производства. Тк для разного окружения требуется разная конфигурация плагинов и режимов работы. Настраиваемые переменные окружения позволяют инициализировать только требуемые для данного окружения механизмы.

```javascript
enum WorkingEnv {
    'genetic', // стратегия работает в режиме генетической оптимизации
    'tester', // стратегия работает в режиме тестирования на истории
    'production', // стратегия работает в режиме реальной торговли
}
```

### `DebutOptions`

Базовые опции для любой торговой стратегии.

```javascript
interface DebutOptions {
    broker: 'tinkoff' | 'binance'; // Тип брокера
    ticker: string; // Тикер
    currency: string; // Валюта
    interval: TimeFrame; // Временной интервал
    amount: number; // Сумма для работы стратегии
    fee?: number; // Налог за операцию в дробях
    id?: number; // Ид конфигурации
    sandbox?: boolean; // Активен ли режим песочницы или торговля на реальные деньги
    margin?: boolean; // Разрешена ли торговля в шорт
    lotsMultiplier?: number; // Множитель лотности, например если нужно сделать х2 или х3 закупку, по умолчанию 1
    equityLevel?: number; // Склько доступно от общего депозита для текущей стратегии
}
```

### `DebutMeta`
Базовый класс для определения мета информации о стратегии. Используется во всех файлах `meta.ts` содержащих мета данные.

```javascript
interface DebutMeta {
    parameters: GeneticSchema; // Параметры оптимизации стратегии
    score: (bot: DebutCore) => number; // Метод подсчета эффективности в генетической оптимизации
    validate: (cfg: DebutOptions) => false | DebutOptions; // Валидация конфигурации
    stats: (bot: DebutCore) => unknown; // Метод для получения статистики по роботу, может использоватся любой плагин статистики
    create: (transport: BaseTransport, cfg: DebutOptions, env: WorkingEnv) => Promise<DebutCore>; // Метод создания стратегии
    ticksFilter?: (solution: DebutOptions) => (tick: Candle) => boolean; // Фильтрация тиков, для удаления их из истории при тестированииях, работает также для генетика
}
```

### `GeneticSchema`
Объект состоящий из [Дескрипторов](#schemadescriptor) полей, описывающий диапазоны ранжинования полей и типы данных в них. Используется для генерации случайных значений, во время мутирования в генетическом алгоритме, или на начальном этапе для создания первого случайного набора данных.

Пример:
```javascript
const parameters: GeneticSchema<SpikesGOptions> = {
    stopLoss: { min: 10, max: 30 }, // float: числа от 10 до 30 с любой дробной частью
    usePeaks: { bool: true }, // boolean: true или false
    bandsPeriod: { min: 10, max: 80, int: true }, // int: целые числа от 10 до 80
    minus: { min: -10, max: -5, int: true }, // int: отрицательные целые числа от -10 до -5
};
```

### `SchemaDescriptor`
Формат ранжирования данных для случайной генерации значений. Поддерживаются `number`, `float` и `boolean` типы.

```javascript
type SchemaDescriptor = SchemaNumberDescriptor | SchemaBoolDescriptor;

type SchemaNumberDescriptor = {
    min: number; // начальное значение
    max: number; // конечное значеие
    int?: boolean; // целочисленное
    odd?: boolean; // Нечетное
};

type SchemaBoolDescriptor = {
    bool: true; // булево
};
```

### `OrderType`
Поддерживаемые типы сделок. *На данный момент поддерживаются только рыночные сделки*

```javascript
enum OrderType {
    'BUY' = 'BUY', // Покупка по маркету
    'SELL' = 'SELL', // Продажа по маркету или шорт, в случае отсутствия позиций и разрешения маржинальной торговли
}
```
### `ExecutedOrder`

```javascript
interface ExecutedOrder {
    // Выбранный брокер для торговли
    broker: string;
    // Тип сделки из OrderType
    type: OrderType;
    // Тикер инструмента на бирже
    ticker: string;
    // Время свечи на которой был исполнен
    time: number;
    // Идентификатор актива на бирже, если поддерживается биржей
    figi?: string;
    // Валюта операции, в которой измеряется баланс например:
    // тикер XRPBTC - валюта сделки будет BTC,
    // тикер BTCUSDT - валюта это USDT,
    // в случае покупки акций это фиат за который продется акция.
    currency: string;
    // Таймфрейм свечей на котором работаем
    interval: TimeFrame;
    // Подпись стратегии (имя)
    author: string;
    // Цена выполнения заявки
    price: number;
    // Запрошеное количество лотов
    lots: number;
    // Размер лота, например в российских акциях в одном лоте может быть 1000 шт, по умолчанию lotSize = 1
    lotSize: number;
    // Размер пункта (Минимальное изменение цены)
    pipSize: number;
    // Фтаг песочницы (Используется в Enterprise версии)
    sandbox: boolean;
    // Является ли сделка закрывающей, то есть гасящей ранее открытую.
    // Для таких сделок будут заполнены поля openId и openPrice
    close: boolean;
    // Цена открытия. Только для сделок закрывающих позицию
    openPrice?: number;
    // Идентификатор сделки создавшей позицию. Только для закрывающих сделок
    openId?: string;
    // Множитель лотности, на него умножались лоты, для закупки. Используется для удобства работы с мартингейл системами.
    lotsMultiplier?: number;
    // Сколько средств берем от выделенных стратегии, значение в процентах считается от opts.amout поля
    // Пример: 0-1, 0 - 0%, 1 - 100%. 0.25 = 25%.
    equityLevel?: number;
    // Была ли выполнена сделка в фазе обучения на тестовых данных
    learning?: boolean;
    // Только для Binance - использовался ли cross margin счет
    margin?: boolean;
    // Только для Binance - использовался ли cross futures счет
    futures?: boolean;
    // Идентификатор сделки
    orderId: string;
    // Сколько лотов было куплено, может отличаться по количеству от запрошенных, по причинам работы биржи
    executedLots: number;
    // Данные о комиссии, валюта комиссии и размер
    commission: { currency: string; value: number };
    // Инидикация выполнения операций на рынке для данной сделки.
    // true - начались сетевые взаимодействия. false - нет или закончились
    processing?: boolean;
}
```
### `Instrument`
Параметры торгового инструмента.

```javascript
interface Instrument {
    // Идентификатор актива на бирже, если поддерживается биржей
    figi?: string;
    // Тикер на бирже
    ticker: string;
    // Размер пункта
    pipSize?: number;
    // Размер одного лота для покупки (по умолчанию 1)
    lot: number;
    // С какой точностью указываются лоты, например значение 6 = 0.000001
    lotPrecision: number;
}
```