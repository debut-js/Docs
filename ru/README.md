<style>
tr td:not(:nth-child(1)) {
   text-align: center;
}
</style>

# Debut

Debut - это экосистема для разработки и запуска торговых стратегий. Аналог известного `ZenBot`, но с гораздо более гибкими возможностями для конструирования стратегий. Все что вам нужно сделать, это придумать и описать точки входа в рынок и подключить нужные [плагины](https://github.com/debut-js/Plugins) для работы. Все остальное - дело техники: **генетические алгоритмы** - помогут подобрать самые эффективные параметры для стратегии (период, стопы, и другие), **модуль подбора тикеров** - поможет найти подходящий для стратегии актив (токен или акцию), на котором она будет работать лучше всего.

В основе Debut лежит архитектура ядра и надстраиваемых плагинов, позволяющих гибко кастомизировать любые решения. Оснвной целью всей экосистемы Debut, является упрощение процесса создания и запуска рабочих торговых роботов на различные биржи.

## Доступно для
<p>
    <img src="https://raw.githubusercontent.com/debut-js/Core/master/.github/assets/alpaca.png" alt="Alpaca API" width="64">
    <img src="https://raw.githubusercontent.com/debut-js/Core/master/.github/assets/binance.png" alt="Binance API" width="64">
    <img src="https://raw.githubusercontent.com/debut-js/Core/master/.github/assets/tinkoff.png" alt="Tinkoff API (Russia only)" width="64">
    <a href="https://www.patreon.com/bePatron?u=57560983"><img src="https://raw.githubusercontent.com/debut-js/Core/master/.github/assets/buy2.png" alt="Request implementation" width="64"></a>
</p>

В проекте есть две стартовые торговые стратегии "Для примера" как нужно работать с системой.

Пример работы стратегии [SpikesG](https://github.com/debut-js/Strategies/tree/master/src/strategies/spikes-grid) за 200 дней. Оптимизация проводилась за 180 дней и 20 дней свободной работы на необученных данных.
Использовался стартовый депозит в размере *500$*

<p align="center"><img src="https://github.com/debut-js/Strategies/raw/master/src/strategies/spikes-grid/img/BATUSDT.png" width="800"></p>

Статистика стратегии собиралась на основе плагина [статистики](https://github.com/debut-js/Plugins/tree/master/packages/stats), по ссылке можно подробнее узнать о значении некоторых статистических данных.

Визуализация выполнена с помощью плагина [Report](https://github.com/debut-js/Plugins/tree/master/packages/report).

## Community edition
Мы верим в силу сообщества! Именно поэтому решили опубликовать проект. Комьюнити версия бесплатная, но имеет некоторые ограничения в коммерческом использовании (доход от торговли стартегий не является коммерцией), а также технические отличия в тестировании стратегий. Присоединяйтесь к комьюнити, вступайте в **[чат разработчиков](https://t.me/joinchat/Acu2sbLIy_c0OWIy)**


## Премиальные версии

### @debut/enterprise-core

<h5>Аггрегатор таймфреймов</h5>
Это модуль ядра, отвечающий за агрегацию тиков `1min` свечей в любые другие доступные временные периоды.
Он позволяет создавать таймфреймы поддерживаемые в `Debut`, даже если они не поддерживаются брокером. А также получать доступ к свече любого старшего таймфрейма, например построить дневные уровни поддержки и сопротивления, снять показания индикаторов с четырех часовых свечей и многое другое. Ниже приведен пример регистрации доступа к `day` таймфрейму.

<h5>Продвинутая эмуляция тиков</h5>
Позволяет эмулировать в тестовой среде тики с максимальной точностью, за счет создания изменений цены на основе `1min` тиков, раздробленных на open, high, low, close. Для сбора таймфреймов используется модуль аггрегации в свечи любого временного интервала.


<h5>Дополнительные колбеки в плагинах</h5>
Дополнительные колбеки, используются в премиальной версии Debut для расширения функционала создания плагинов. Подробнее можно прочитать в разделе описания плагинов.

Версия Enterprise - это готовый набор инструментов для «больших парней», для тех, кто занимается торговлей услугами или профессионально создает стратегии. Всё здесь! И всё это готово работать на вас и увеличивать скорость вашей разработки.
 **(15$/месяц [Купить сейчас!](https://www.patreon.com/bePatron?u=57560983))**

<table>
<thead>
<tr>
<th> Функциональность </th>
<th> Community </th>
<th> Enterprise </th>
</tr>
</thead>
<tbody> <tr>
<td> Тестер стратегий </td>
<td align = "center"> ✅ </td>
<td align = "center"> ✅ </td>
</tr>
<tr>
<td> Эмуляция тиков OHLC в тестере </td>
<td align = "center"> ✅ </td>
<td align = "center"> ✅ </td>
</tr>
<tr>
<td> Иснтурмент поиска (finder), подходящих для стратегии активов </td>
<td align = "center"> ✅ </td>
<td align = "center"> ✅ </td>
</tr>
<tr>
<tr>
<td> Данные свечей M1 для имитации тиков </td>
<td align = "center"> ❌ </td>
<td align = "center"> ✅ </td>
</tr>
<tr>
<td> Синтетическая эмуляция тиков в тестере (размер тика не более 0,75%) </td>
<td align = "center"> ❌ </td>
<td align = "center"> ✅ </td>
</tr>
<tr>
<td> Доступ к старшим свечам из рабочего таймфрейма </td>
<td align = "center"> ❌ </td>
<td align = "center"> ✅ </td>
</tr>
<tr>
<td> <b> Alpaca </b> поддерживает `5min`,` 15min` и другие временные фреймы debut </td>
<td align = "center"> ❌ </td>
<td align = "center"> ✅ </td>
</tr>
<td> Анализатор отчетов `finder`. Создает скриншоты из json файлов отчетов и групирует их по эффективности</td>
<td align = "center"> ❌ </td>
<td align = "center"> ✅ </td>
</tr>
</tbody>
</table>

### Personal edition
*Не включает готовые стратегии*

- Enterprise core включено!
- Отчет со скриншотами сделок и статистикой прямо в мессенджер
- Формула управления капиталом для автоматического расчета капитала стратегии
- Помощь в запуске и настройке
- Готов к запуску на VPS / VDS или в облаке
- Панель управления * [еще в процессе]

### Бизнес-версия
- Система быстрого подключения токенов (клиентов) для создания торговых сигналов, например для продажи подписки
- Легальное использование Дебют для бизнеса

**Узнайте цену, отправив запрос на [sales@debutjs.io](mailto:sales@debutjs.io)**

**Дисклеймер**

- Debut не гарантирует 100% вероятности получения прибыли. Используйте его на свой страх и риск, полагаясь на собственный проффесионализм.
- Криптовалюта это глобальный эксперимент, поэтому Debut - тоже. То есть оба могут выйти из строя в любой момент.



## Прямой эфир сделок

<table>
<thead>
    <tr>
        <th> Крипто валюты </th>
        <th> Акции </th>
    </tr>
</thead>
<tbody>
<tr>
<td>
<iframe id="preview" style="height:500px;width:500px;" src="https://xn--r1a.website/s/debutjs"></iframe>
</td>
<td>
<iframe id="preview" style="height:500px;width:500px;" src="https://xn--r1a.website/s/debutjs2"></iframe>
</td>
</tr>
</tbody>
</table>


<hr/>

## Ядро Debut

### Runtime Данные

<h5>

*`this.candles[]`*

</h5>

__Описание:__ Массив свеч [Candle](#candle) (10 последних), `this.candles[0]` -  текущая не закрытая свеча, `this.candles[1]` - последняя закрытая свеча.

__Пример:__
```javascript
const currentCandle = this.candles[0];
const prevCandle = this.candles[1];

// Быстрый доступ к двум последним свечам
this.currentCandle // эквивалентно this.candles[0]
this.prevCandle // эквивалентно this.candles[1]
```

<h5>

*`this.orders[]`*

</h5>

__Описание:__ Массив открытых позиций [ExecutedOrder](#executedorder) в порядке открытия `this.orders[0]` - первая

__Пример:__
```javascript
const currentOrder = this.orders[0];
```

<h5>

*`this.plugins`*

</h5>

__Описание:__ Публичные методы плагинов. Объект `this.plugins` формируется автоматически при регистрации плагинов. По правилу: `this.plugins[name] = PluginAPI`, где name - это уникальное имя плагина.

__Пример:__
```javascript
this.plugins.report.disableProfitPlot(); // вызов метода управления плагином report
```
### Публичные методы

<h5>

*`this.registerPlugins(PluginInterface[])`*

</h5>

__Описание:__ Регистрация плагинов. Может быть вызвана в любой удобный момент, но рекомендуется регистрировать все необходимые плагины на этапе создания в конструкторе стратегии или в конструкторе окружения в мета файле

__Пример:__
```javascript
this.registerPlugins([debugPlugin()]);
```

<h5>

*`this.start()`*

</h5>

__Описание:__ При вызове будет создана подписка на тики по текущему транспорту (Binance/Tinkfff/Tester). В продакшене создает веб-сокет соединение с биржей и получает обновления по тикеру из настроек.

__Пример:__
```javascript
this.start();
```

<h5>

*`this.getName()`*

</h5>

__Описание:__ Возвращает имя конструктора стратегии, по сути название стратегии. Для различных нужд, например для логирования, чтобы было понятно по какой именно стратегии произошло событие.

__Пример:__
```javascript
const name = this.getName();
console.log(name, this.orders);
```

<h5>

*`this.closeAll(): Promise<ExecutedOrder[]>;`*

</h5>

__Описание:__ Последовательно закрывает все открытые позиции из массива `this.orders`, возвращает массив [ExecutedOrders](#executedorder) закрытых сделок

__Пример:__
```javascript
await this.closeAll();
```

<h5>

*`this.createOrder(operation: OrderType): Promise<ExecutedOrder>;`*

</h5>

__Описание:__ Создает сделку по маркету с направлением [OrderType](#ordertype)

__Пример:__
```javascript
const executedOrder = await this.createOrder(OrderType.BUY);
```

<h5>

*`this.closeOrder(closing: ExecutedOrder): Promise<ExecutedOrder>;`*

</h5>

__Описание:__ Закрывает указанную заявку. Принимает на вход ранее исполненную заявку [ExecutedOrder](#executedorder)

__Пример:__
```javascript
const openedOrder = this.orders[0];
const executedOrder = await this.closeOrder(openedOrder);
```

<h5>

*`this.learn(days: number): Promise<void>;`*

</h5>

__Описание:__ Подача боту исторических данных в качестве этапа пред стартом. Необходимо для того чтобы бот вошел в рынок имея данные индикаторов и возможно открыте сделки, чтобы совершить плавный переход к реальным сделкам. Все сделки открытые в режиме обучения, будут закрыты безопасно минуя реальный баланс брокера.

__Пример:__
```javascript
const bot = await meta.create(getTransport(config), config, WorkingEnv.production);
await bot.learn(60);
await bot.start();
```

<h5>

*`this.useMajorCandle(timeframe: TimeFrame): void;`*

</h5>

***Только для Enterprise версии***

__Описание:__ Создание аггрегатора свеч, который будет накапливать данные для формирования свечей старших таймфреймов и вызывать соответствующий хук при окончании их формирования.

__Пример:__
```javascript
/**
 * Конструктор торговой стратегии Debut
 */
constructor(transport: BaseTransport, opts: DebutOptions) {
    super(transport, opts);
    //...
    this.useMajorCandle('day'); // регистрация аггрегатора дневных временных интервалов
    this.useMajorCandle('4h'); // регистрация аггрегатора четырех часовых интервалов
}

/**
 * Хук для отслеживания закрытий свечей из старших тайм фреймов
 */
async onMajorCandle(candle: Candle, timeframe: TimeFrame) {
    console.log(candle); // { o: ..., h: ..., l: ..., c: ..., v: ..., time: ... };
    console.log(timeframe); // 'day' or '4h'

    // Обновление дневного индикатора, например SMA
    if (timeframe === 'day') {
        this.daySMAValue = this.daySMA.nextValue(candle.c);
    }
}

```

### Хуки
Хуки - это набор `protected` методов для быстрого доступа к тикам, новым свечам, созданию сделок и тд...

Реализуйте любой из этих методов в стратегии, и он автоматически будет вызываться при том или ином событии во время работы стратегии.

Выполнено закрытие одной из позиций:

`onOrderClosed(order: ExecutedOrder, closing: ExecutedOrder): Promise<void>`

Выполнено открытие позиции:

`onOrderOpened(order: ExecutedOrder): Promise<void>`

Свеча закрылась и ее можно обработать (например передать в индикаторы):

`onCandle(candle: Candle): Promise<void>`

Пришел новый тик из вебсокета биржи или тестера:

`onTick(tick: Candle): Promise<void>`

Свеча из старшего таймфрейма закрылась:
***Только для Enterprise версии***

`onMajorCandle(candle: Candle, timeframe: TimeFrame): Promise<void>`

## Модули командной строки

<h3> Генетический оптимизатор </h3>

В его основе лежит модуль генетики [async-genetic](https://www.npmjs.com/package/async-genetic), который позволяет находить оптимальные решения для различных задач. Генетический оптимизатор способен гораздо более эффективно подбирать наилучшие параметры, в сравнении сравнению с простым случайным перебором значений (Brutforce).

### Одиночный **genetic**

Одиночный вызов генетического оптимизатора, используется для настройки стратегии под оптимизацию во время разработки. Например, для проверки на корректность [схемы оптимизации](#geneticschema), прочих этапов создания робота и его работу по время оптимизации в целом.

Но может применятся и как разовая оптимизация на заранее известном инструменте, для быстрого получения результата.

Запускается при помощи вызова команды:

```bash
npm run genetic -- [...args]
```
<h4> Параметры запуска </h4>

<h5>

*`--bot=...`*

</h5>

__Описание:__ Имя торгового робота из файла `schema.json`

__Пример:__ `--bot=SpikesG`

<h5>

*`--ticker=...`*

</h5>

__Описание:__ Инструмент для работы, обязательно должен быть в файле `cfgs.ts`, в директории стратегии

__Пример:__ `--ticker=AAPL`, `--ticker=BTCUSDT`

<h5>

*`--amount=...`*

</h5>

__Описание:__ Начальная сумма для торговли (от нее считается [equityLevel](#debutoptions)) `schema.json`

__Пример:__ `--amount=500`

<h5>

*`--days=...`*

</h5>

__Описание:__ Число дней для загрузки истории, если она есть. Загружаемая история сохраняется в директорию `./history` для переиспользования

__Пример:__ `--days=200`

<h5>

*`--gap=...`*

</h5>

__Описание:__ Сколько дней отступить от сегодня перед началом запроса истории

__Рекомендации:__ Используется для создания интервала котором не прходило обучение. Если мы передали настройку `--days=150` и настройку `--gap=50` то образуется 50 дней истории для запуска в тестере и тестировании на необученных данных, достаточно будет передать в тестере `--days=200` тогда мы захватим весь период обучения, плюс новые 50 дней отступа

__Пример:__ `--gap=20`

<h5>

*`--pop=...`*

</h5>

__Описание:__ Размер популяции в генетическом алгоритме (популяция это кол-во создаваемых стратегий)

__Рекомендации:__ Размер популяции рекомендуется устанавливать в диапазонах от `100` до `1500`, но больше не значит лучше! Значение весьма индивидуально, большие популяции увеличивают вероятность мутаций и прочих случайных явлений. Делайте фокус на количество поколений

__Пример:__ `--pop=500`

<h5>

*`--gen=...`*

</h5>

__Описание:__ Количество поколений в оптимизации

__Рекомендации:__ Сила генетики в поколениях, рекомендуемые значения от `10` до `100`, больше значит лучше. Однако следите за переученностью, проверяя стратегию на новых исторических данных. Велика вероятность адаптации к конкретным условиям изменения цены, при очень большом количестве поколений.

__Пример:__ `--gen=20`

<h5>

*`--ohlc`*

</h5>

__Описание:__ Механизм предназначен для более близкого точного отслеживания изменения цен. Разбивает каждую свечу в истории на 4 тика.

__Пример:__ `--ohlc`

<h5>

*`--best=...`*

</h5>

__Описание:__ Сколько лучших результатов выдать в консоль по окончанию оптимизации, по умолчанию `30`

__Пример:__ `--best=20`


<h5>

*`--log`*

</h5>

__Описание:__ Выводить ли промежуточные данные о поколении в консоль

__Рекомендации:__ Используйте при разработке стратегий и проверки их в генетике, или вообще всегда.

__Пример:__ `--log`


Пример запуска:

```bash
npm run compile && npm run genetic -- --bot=SpikesG --ticker=CRVUSDT --days=180 --gap=20 --gen=20 --pop=100 --log --amount=500
```


### Поиск тикеров **finder**
Это модуль подбора тикера под стратегию, перебирает все доступные тикеры для акций из файла `./stocks.json`, для криптовалюты из файла `./crypt.json`
Для каждого тикера выполняется генетический подбор параметров в процессе. На выходе вы получаете готовые результаты для каждого тикера. Удобно оставить на ночь.

Результаты будут создаваться в виде отчетов в JSON формате конфигурация + ее статистика. Отчеты складываются в папку `./public/reports/...`

Анализировать данные отчетов нужно следующим образом. В файле с именем тикера, вы увидете 30 варинатов конфигураций, которые показали лучший результат после генетической оптимизации. В файле json результаты ррасполагаются сверху вниз от худшего к лучшему. Лучшие результаты всегда снизу. Поле `id` в конфиге, позволяет установить связь с результатом это позволит понять, какой был выбран конфиг для запуска.

При работе модифицируются файлы `stocks.json` или `crypt.json`, не забудьте откатить изменения после завершения подбора тикеров.

*Запускается при помощи вызова команды:*
```bash
npm run finder -- [...args]
```

<h4> Параметры запуска </h4>

Основные параметры те же, что и у [genetic](#Одиночный-genetic), с одним отличием

<h5>

*`--crypt`*

</h5>

__Описание:__ Использовать ли файл `crypt.json` для работы (по умолчанию используется `stocks.json` со списком акций)

__Пример:__ `--crypt`

__Рекомендации:__ Процесс заканчивает работу после обработки одного тикера, для цикличных перезапусков используйте `pm2`, ниже приведены примеры запусков процесса поиска тикеров.

*Mac/Linux*
```bash
npm run compile && pm2 start finder -n instance -- --ticker=NDAQ --bot=SpikesG --amount=1000 --days=1000 --log --useTicks --pop=100 --gen=50
```

*Windows:*
```bash
npm run compile && pm2 start node_modules/@debut/enterprise-core/lib/cli/finder.js -f -- --ticker=ZILUSDT --bot=SpikesG --amount=500 --gen=50 --pop=300 --days=180 --gap=20 --log --useTicks --crypt
```
### Тестер страгий **tester**
Это модуль тестирования стратегий. Он используется во время разработки, для проверки открытия и закрытия позиций в нужных местах и работы стрегии в целом. Также для создания визуализаций готовых алго стратегий.

*Запускается при помощи вызова команды:*
```bash
npm run testing -- [...args]
```
<h4>Параметры запуска</h4>

<h5>

*`--bot=...`*

</h5>

__Описание:__ Имя торгового робота из файла `schema.json`

__Пример:__ `--bot=SpikesG`

<h5>

*`--ticker=...`*

</h5>

__Описание:__ Инструмент для работы, обязательно должен быть в файле `cfgs.ts`, в директории стратегии

__Пример:__ `--ticker=AAPL`, `--ticker=BTCUSDT`

<h5>

*`--days=...`*

</h5>

__Описание:__ Число дней для загрузки истории, если она есть. Загружаемая история сохраняется в директорию `./history` для переиспользования

__Пример:__ `--days=200`

<h5>

*`--gap=...`*

</h5>

__Описание:__ Сколько дней отступить от сегодня перед началом запроса истории

__Рекомендации:__ Используется для создания интервала котором не прходило обучение. Если мы передали настройку `--days=150` и настройку `--gap=50` то образуется 50 дней истории для запуска в тестере и тестировании на необученных данных, достаточно будет передать в тестере `--days=200` тогда мы захватим весь период обучения, плюс новые 50 дней отступа

__Пример:__ `--gap=20`

<h5>

*`--ohlc`*

</h5>

__Описание:__ Механизм предназначен для более близкого точного отслеживания изменения цен. Разбивает каждую свечу в истории на 4 тика.

__Пример:__ `--ohlc`

<h5>

*Пример запуска:*
```bash
npm run compile && npm run testing -- --ticker=TSLA --bot=SpikesG --days=200 --olhc
```

## Разработка плагинов
Архитектура плагинов посторения на использовании вызовов определенных фукнций (далее хуки), с целью перехвата событий происходящих в системе.
Некоторые виды хуков позволяют останавливать события, некоторые имеют пассивный статус без влияния на происходящее. Архитектура плагина должны быть выстраена таким образом, чтобы не влиять на производительность в генетическом оптимизаторе.

Весь плагин это функция, возвращающая объект содержаший поле `name` - это имя плагина, оно должно быть уникально в рамках используемых плагинов, `api` - это внешние методы плагина, для вызовов внутри стратегии, ну и остальные поля объекта это набор хуков.

```javascript
export function pluginConstructor(): PluginInterface {
    const variable = 23;
    return {
        name: 'MyPluginName',
        api: {
            getVariable() {
                return variable;
            },
        // ... hooks
    };
}

```

### Хуки
Ниже перечислен весь набор доступных хуков плагинов.

*`[onInit]: () => void;`*

Инициализация плагина, здесь можно что-нибудь создать или подключить другой плагин по его имени используя вызов `this.findPlugin(name)`

*`[async onStart]: () => Promise<void>;`*

Стратегия подписалась на биржевые данные и получает их в реальном времени.

*`[async onDispose]: () => Promise<void>;`*

Стратегия отписалась от биржевых данных и завершила работу. Хорошая возможность подчистить память плагина.

*`[async onBeforeOpen]: (order: OrderOptions) => Promise<boolean | void>;`*

Стратегия пытается открыть сделку, опции сделки доступны в качестве аргумента. Хук поддерживает режим блокировки действия если возвращает `true`, в таком случае сделка не будет создана.

*`[async onOpen]: (order: ExecutedOrder) => Promise<void>;`*

Сделка создана, можно получить ее как аргумент и собрать нужные данные о ней. На момент вызова хука операции на рынке уже исполнены.

*`[async onBeforeClose]: (order: OrderOptions, closing: ExecutedOrder) => Promise<boolean | void>;`*

Стратегия пытается закрыть сделку `closing`, опции сделки закрытия доступны в качестве аргумента `order`. Хук поддерживает режим блокировки действия если возвращает `true`, в таком случае сделка не будет закрыта, но попытки ее закрыть будут продолжаться по логике стратегии.

*`[async onClose]: (order: ExecutedOrder, closing: ExecutedOrder) => Promise<void>;`*

Сделка закрыта, в качестве аргументов передаются сделка которую закрываем `closing` и сделка которой закрываем `order`. На момент вызова хука операции на рынке уже исполнены.

*`[async onCandle]: (candle: Candle) => Promise<void>;`*

Текущая свеча закрылась. Данные свечи доступны в аргументе `candle`

*`[async onAfterCandle]: (candle: Candle) => Promise<void>;`*

Текущая свеча закрылась и отработали хуки `onCandle` можно что-нибудь сделать.

*`[async onTick]: (tick: Candle) => Promise<void>;`*

Пришел новый тик по текущей свече. Все тики идут в этот обработчик. Также поддерживает блокировку события, если вернет `true`, тик не будет передан стратегии. Используется например для ограничений торговых сессий. Чтобы отключать стратегию от рынка виртуально в зависимости от времени или дня недели или фазы луны.

*`[async onMajorCandle]: (tick: Candle, timeframe: TimeFrame) => Promise<void>;`*
***Только для Enterprise версии***
Сформирована новая свеча для старшего таймфрейма, которы задал пользователь при вызове метода `this.useMajorCandle('1h');` в реализации стратегии. Плагины также самостоятельно могут вызывать подписку на использвоание старших фреймов, используя контекст плагина `this.debut.useMajorCandle` или `ctx.debut.useMajorCandle('1h');`


### Контекст выполнения

Все хуки выполняются в контексте плагина, обращения к `this.` внутри любого хука будут привязаны к объекту ниже. Все аргументы передаваемые через хуки мутабильны, так что будьте осторожны.

Сама стратегия доступна как `this.debut` и вы имеете доступ ко всем публичным методам и атрибутам ядра.

`this.debut.orders` - список активных сделок, `this.debut.closeOrder` - закроет сделку, `this.debut.opts` - поможет получить доступ к настройкам стратегии.


Интерфейс контекста
```javascript
interface PluginCtx {
    findPlugin<T extends PluginInterface>(name: string): T;
    debut: DebutCore;
}
```

### Примеры
#### Простой плагин
Рассмотрим пример одного из самый простых плагинов, который прибавляет полученую прибыль к существующему балансу стартегии.

```javascript
import { PluginInterface } from '@debut/types';
import { orders } from '@debut/plugin-utils';

export function reinvestPlugin(): PluginInterface {
    // this = undefined здесь
    // но можно использовать отложенное присвоение так:
    let ctx: PluginCtx;

    return {
        name: 'reinvest',

        onInit() {
            ctx = this;
        },

        async onClose(order, closing) {
            // this = PluginCtx  здесь
            if (!order.openPrice) {
                return;
            }

            const profit = orders.getCurrencyProfit(closing, order.price) - order.commission.value;

            // this -> PluginCtx
            this.debut.opts.amount += profit;
        },
    };
}

```

#### Плагин шаг за шагом


**Создадим общий тип плагина и экспортируем его**
```javascript
export interface DynamicTakesPlugin extends PluginInterface {
    name: 'dynamicTakes';
    api: Methods;
}
```

**Экспортируем тип с параметрами плагина, для его подключения к debut.opts**
```javascript
export type DynamicTakesPluginOptions = {
    trailing?: boolean;
    ignoreTicks?: boolean;
    maxRetryOrders?: number;
};
```

**Отдельно объявим интерфейс публичных методов плагина (он приватный, экспорта нет)**
```javascript
interface Methods {
    setForOrder(orderId: string, takePrice: number, stopPrice: number): void;
    getTakes(orderId: string): OrderTakes;
}
```

**Экспортируем интерфейс API плагина для вызова через `this.plugins.dynamicTakes.setForOrder()` из стратегии**
```javascript
export interface DynamicTakesPluginAPI {
    dynamicTakes: Methods;
}
```

*NB!: Все публичные методы плагинов будут доступны из стратегии с помощью обращения через `this.plugins[имя плагина]`*


Полный листинг плагина доступен [здесь](https://github.com/debut-js/Plugins/blob/master/packages/dynamic-takes/index.ts)


## Типы данных **@debut/types**

Типы данных располагаются в отдельном пакете, для установки выполнить команду

```bash
npm i --save-dev @debut/types
```
### `Candle`
Форма представление рыночных данных. Используется как для тиков, так и для сформировавшихся свеч. Унифицированный стандарт, не зависит от выбора торговой площадки.

```javascript
interface Candle {
    o: number;
    c: number;
    h: number;
    l: number;
    v: number;
    time: number;
}
```
### `TimeFrame`
Унифицированный формат таймфрейма для работы стратегии, в списке только поддерживаемые форматы.

```javascript
type TimeFrame = '1min' | '3min' | '5min' | '15min' | '30min' | '1h' | '2h' | '4h' | 'day' | 'week' | 'month';
```
### `WorkingEnv`
Переменные окружения среды выполнения. Необходимо разделять все этапы производства. Тк для разного окружения требуется разная конфигурация плагинов и режимов работы. Настраиваемые переменные окружения позволяют инициализировать только требуемые для данного окружения механизмы.

```javascript
enum WorkingEnv {
    'genetic', // стратегия работает в режиме генетической оптимизации
    'tester', // стратегия работает в режиме тестирования на истории
    'production', // стратегия работает в режиме реальной торговли
}
```

### `DebutOptions`

Базовые опции для любой торговой стратегии.

```javascript
interface DebutOptions {
    broker: 'tinkoff' | 'binance'; // Тип брокера
    ticker: string; // Тикер
    currency: string; // Валюта
    interval: TimeFrame; // Временной интервал
    amount: number; // Сумма для работы стратегии
    fee?: number; // Налог за операцию в дробях
    id?: number; // Ид конфигурации
    sandbox?: boolean; // Активен ли режим песочницы или торговля на реальные деньги
    margin?: boolean; // Разрешена ли торговля в шорт
    lotsMultiplier?: number; // Множитель лотности, например если нужно сделать х2 или х3 закупку, по умолчанию 1
    equityLevel?: number; // Склько доступно от общего депозита для текущей стратегии
}
```

### `DebutMeta`
Базовый класс для определения мета информации о стратегии. Используется во всех файлах `meta.ts` содержащих мета данные.

```javascript
interface DebutMeta {
    parameters: GeneticSchema; // Параметры оптимизации стратегии
    score: (bot: DebutCore) => number; // Метод подсчета эффективности в генетической оптимизации
    validate: (cfg: DebutOptions) => false | DebutOptions; // Валидация конфигурации
    stats: (bot: DebutCore) => unknown; // Метод для получения статистики по роботу, может использоватся любой плагин статистики
    create: (transport: BaseTransport, cfg: DebutOptions, env: WorkingEnv) => Promise<DebutCore>; // Метод создания стратегии
    ticksFilter?: (solution: DebutOptions) => (tick: Candle) => boolean; // Фильтрация тиков, для удаления их из истории при тестированииях, работает также для генетика
}
```

### `GeneticSchema`
Объект состоящий из [Дескрипторов](#schemadescriptor) полей, описывающий диапазоны ранжинования полей и типы данных в них. Используется для генерации случайных значений, во время мутирования в генетическом алгоритме, или на начальном этапе для создания первого случайного набора данных.

Пример:
```javascript
const parameters: GeneticSchema<SpikesGOptions> = {
    stopLoss: { min: 10, max: 30 }, // float: числа от 10 до 30 с любой дробной частью
    usePeaks: { bool: true }, // boolean: true или false
    bandsPeriod: { min: 10, max: 80, int: true }, // int: целые числа от 10 до 80
    minus: { min: -10, max: -5, int: true }, // int: отрицательные целые числа от -10 до -5
};
```

### `SchemaDescriptor`
Формат ранжирования данных для случайной генерации значений. Поддерживаются `number`, `float` и `boolean` типы.

```javascript
type SchemaDescriptor = SchemaNumberDescriptor | SchemaBoolDescriptor;

type SchemaNumberDescriptor = {
    min: number; // начальное значение
    max: number; // конечное значеие
    int?: boolean; // целочисленное
    odd?: boolean; // Нечетное
};

type SchemaBoolDescriptor = {
    bool: true; // булево
};
```

### `OrderType`
Поддерживаемые типы сделок. *На данный момент поддерживаются только рыночные сделки*

```javascript
enum OrderType {
    'BUY' = 'BUY', // Покупка по маркету
    'SELL' = 'SELL', // Продажа по маркету или шорт, в случае отсутствия позиций и разрешения маржинальной торговли
}
```
### `ExecutedOrder`

```javascript
interface ExecutedOrder {
    // Выбранный брокер для торговли
    broker: string;
    // Тип сделки из OrderType
    type: OrderType;
    // Тикер инструмента на бирже
    ticker: string;
    // Время свечи на которой был исполнен
    time: number;
    // Идентификатор актива на бирже, если поддерживается биржей
    figi?: string;
    // Валюта операции, в которой измеряется баланс например:
    // тикер XRPBTC - валюта сделки будет BTC,
    // тикер BTCUSDT - валюта это USDT,
    // в случае покупки акций это фиат за который продется акция.
    currency: string;
    // Таймфрейм свечей на котором работаем
    interval: TimeFrame;
    // Подпись стратегии (имя)
    author: string;
    // Цена выполнения заявки
    price: number;
    // Запрошеное количество лотов
    lots: number;
    // Размер лота, например в российских акциях в одном лоте может быть 1000 шт, по умолчанию lotSize = 1
    lotSize: number;
    // Размер пункта (Минимальное изменение цены)
    pipSize: number;
    // Фтаг песочницы (Используется в Enterprise версии)
    sandbox: boolean;
    // Является ли сделка закрывающей, то есть гасящей ранее открытую.
    // Для таких сделок будут заполнены поля openId и openPrice
    close: boolean;
    // Цена открытия. Только для сделок закрывающих позицию
    openPrice?: number;
    // Идентификатор сделки создавшей позицию. Только для закрывающих сделок
    openId?: string;
    // Множитель лотности, на него умножались лоты, для закупки. Используется для удобства работы с мартингейл системами.
    lotsMultiplier?: number;
    // Сколько средств берем от выделенных стратегии, значение в процентах считается от opts.amout поля
    // Пример: 0-1, 0 - 0%, 1 - 100%. 0.25 = 25%.
    equityLevel?: number;
    // Была ли выполнена сделка в фазе обучения на тестовых данных
    learning?: boolean;
    // Только для Binance - использовался ли cross margin счет
    margin?: boolean;
    // Только для Binance - использовался ли cross futures счет
    futures?: boolean;
    // Идентификатор сделки
    orderId: string;
    // Сколько лотов было куплено, может отличаться по количеству от запрошенных, по причинам работы биржи
    executedLots: number;
    // Данные о комиссии, валюта комиссии и размер
    commission: { currency: string; value: number };
    // Инидикация выполнения операций на рынке для данной сделки.
    // true - начались сетевые взаимодействия. false - нет или закончились
    processing?: boolean;
}
```
### `Instrument`
Параметры торгового инструмента.

```javascript
interface Instrument {
    // Идентификатор актива на бирже, если поддерживается биржей
    figi?: string;
    // Тикер на бирже
    ticker: string;
    // Размер пункта
    pipSize?: number;
    // Размер одного лота для покупки (по умолчанию 1)
    lot: number;
    // С какой точностью указываются лоты, например значение 6 = 0.000001
    lotPrecision: number;
}
```